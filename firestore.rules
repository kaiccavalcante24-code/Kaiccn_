/**
 * @file Firebase Security Rules for Firestore
 *
 * Core Philosophy:
 * This ruleset prioritizes security by strictly controlling access to user data and segregating admin-only data. It employs path-based ownership for user profiles and links, and a dedicated collection for managing admin roles. Rules are designed to prevent unauthorized access and maintain data integrity.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information, accessible only to the user themselves.
 * - /users/{userId}/links/{linkId}: Stores links associated with a specific user, accessible only to the user.
 * - /click_events/{clickEventId}: Stores click events, writable by anyone (including unauthenticated users) but readable only by admins.
 * - /roles_admin/{userId}: Presence of a document grants admin privileges to the corresponding user.
 * - /admin/traffic_reports/{reportId}: Stores aggregate traffic reports, accessible only to admins.
 *
 * Key Security Decisions:
 * - User data (profiles and links) is strictly owned by the user, enforced through path-based rules.
 * - Click event creation is public (including unauthenticated users) to allow for easy tracking.
 * - Admin privileges are granted by the presence of a document in the `roles_admin` collection.
 * - Listing user documents is allowed for the owner, denied otherwise.
 * - Strict separation of user and admin data is enforced through distinct collection paths and access controls.
 *
 * Denormalization for Authorization:
 * - User ownership is determined by the document path (e.g., /users/{userId}), eliminating the need for `get()` calls to verify ownership.
 * - Admin status is determined by the existence of a document in the /roles_admin/{userId} collection, avoiding complex role lookups.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to user profiles based on path-based ownership. Only the user themselves can read or modify their profile.
     * @path /users/{userId}
     * @allow (get, create, update, delete) if the request.auth.uid matches the userId.
     * @deny (get, create, update, delete) if the request.auth.uid does not match the userId.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      // Check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the request is made by the existing owner
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get: if isOwner(userId);
      allow list: if request.auth.uid == userId;

      // Allow the user to create their own profile
      allow create: if isOwner(userId);

      // Allow the user to update their own profile
      allow update: if isExistingOwner(userId);

      // Allow the user to delete their own profile
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows access to links associated with a user profile based on path-based ownership. Only the user themselves can read or modify their links.
     * @path /users/{userId}/links/{linkId}
     * @allow (get, create, update, delete) if the request.auth.uid matches the userId.
     * @deny (get, create, update, delete) if the request.auth.uid does not match the userId.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/links/{linkId} {
      // Check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the request is made by the existing owner
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      // Allow the user to create links
      allow create: if isOwner(userId);

      // Allow the user to update their own links
      allow update: if isExistingOwner(userId);

      // Allow the user to delete their own links
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to create click events, but restricts reading to admins only.
     * @path /click_events/{clickEventId}
     * @allow (create) anyone, even unauthenticated users.
     * @allow (get, list) only to users who are admins.
     * @deny (get, list) to non-admin users.
     * @deny (update, delete) always.
     * @principle Allows public writes but restricts reads to admins.
     */
    match /click_events/{clickEventId} {
      // Check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

       // Helper function to check if the user is an admin
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }

      // Allow anyone to create click events
      allow create: if true;

      // Only admins can read click events
      allow get: if isAdmin();
      allow list: if false;

      // No one can update or delete click events
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows only admins to create, read, update, and delete documents. Admin status is determined by the existence of a document in this collection.
     * @path /roles_admin/{userId}
     * @allow (get, create, update, delete) only to users who are admins.
     * @deny (get, create, update, delete) to non-admin users.
     * @principle Uses DBAC (Database-Based Access Control) to grant admin privileges based on document existence.
     */
    match /roles_admin/{userId} {
      // Check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

       // Helper function to check if the user is an admin
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }

      // Only admins can read the role
      allow get: if isAdmin() && request.auth.uid == userId;
      allow list: if false; // Prevent listing of all admins.  Important for security

      //Only admins can create another admins
      allow create: if isAdmin();

      // Only admins can update another admins
      allow update: if isAdmin();

      // Only admins can delete another admins
      allow delete: if isAdmin();
    }

    /**
     * @description Allows only admins to create, read, update, and delete traffic reports.
     * @path /admin/traffic_reports/{reportId}
     * @allow (get, create, update, delete) only to users who are admins.
     * @deny (get, create, update, delete) to non-admin users.
     * @principle Restricts access to aggregate traffic data to administrators.
     */
    match /admin/traffic_reports/{reportId} {
      // Check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

       // Helper function to check if the user is an admin
      function isAdmin() {
        return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
      }

      // Only admins can read traffic reports
      allow get: if isAdmin();
      allow list: if isAdmin();

      // Only admins can create traffic reports
      allow create: if isAdmin();

      // Only admins can update traffic reports
      allow update: if isAdmin();

      // Only admins can delete traffic reports
      allow delete: if isAdmin();
    }
  }
}